<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Bar charts everywhere</title>
        <script type="text/javascript" src="d3/d3.js"></script>
        <style type="text/css">
          


        </style>
    </head>
    <body>
        <script type="text/javascript">


        	var margin = {top: 20, right: 20, bottom: 30, left: 40};
			var width = 960 - margin.left - margin.right;
			var height = 500 - margin.top - margin.bottom;

        	// Create svg canvas

			var svg = d3.select("body")
			.append("svg")
			.attr("width",width+margin.left+margin.right)
			.attr("height",height+margin.bottom+margin.top)
			.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            // Loading data

            var stocks;
            var ByDate;

            d3.csv("stocks.csv", function(data) {

            // DATE PARSING FUNCTIONS

            var parseDate = d3.timeParse("%b %Y");
  			var formatTime = d3.timeFormat("%Y")

  			// SCALE DEFINITIONS

  			var x0 = d3.scaleBand()
				.range([0,width], .2);


			var x1 = d3.scaleBand()
			    .padding(0.2)

			var y = d3.scaleLinear()
			    .range([height,0]);

			var xStack = d3.scaleBand()
				.range([0,width])
				.align(0.1)

			var yStack = d3.scaleLinear()
				.range([height,0])


			// DATA PREPROCESSING 


			// Construct the dataset that we'll use for both stackedBar and groupedBar
  			// stock values by date, grouped by year

  			var ByYear = d3.nest()
  			.key(function(d){ return formatTime(parseDate(d.date));})
  			.entries(data);

  			/* ByYear :  [{key:"2000",values:[{symbol:MSFT, date="Jan 2000",price="39.81"},{},.....]},{key = 2001,}  ] */
  			var YearMean = [];

  			ByYear.forEach(function(Year) {

  				var BySymbol = d3.nest()
  				.key(function(d) {return d.symbol;})
  				.rollup(function(e) {return d3.mean(e,function(d) {return d.price;})})
  				.object(Year.values);

  			/*BySymbol contains the mean of the stock based on the current year in the iteration, by symbol : {MSFT:55,AMZN:58,...} */ 
  				YearMean.push({
  					key: +Year.key,
  					values: BySymbol
  				});
  			});


  			/*YearMean contains the year as key, and the stocks mean by symbol in objets in the values array : [{key:2000,values:{MSFT:46,AMZN:98,...}}] */ 
  			/* Creation of final dataset */
  			var stocks = YearMean.map(function(d) {
  				// Add the year 
  				var final= { year: d.key};

  				// Add the stocks by symbol by copying them into final
  				// object.keys(d.values) gets into d.values, forEach gets all the d.values (symbols) and adds them to the final data
  				Object.keys(d.values).forEach(function(key) {
  					final[key] = d.values[key];
  				});

  				return final;

  			});

  			/* Stocks now has the following structure : [{year:2000,MSFT:46,AMZN:89,..},{....}]*/

  			// USEFULL VARIABLES FOR SCALES

  			// keys has the array with the symbol names, usefull for the x1 domain

  			var keys = d3.keys(stocks[0]).slice(1);
  			// total has the totals for each year of all the stock means, usefull for the yStack domain
  			var total =[];
  			stocks.forEach(function(d){
  				total.push(d3.sum(keys,function(symbol){return d[symbol];}))
  			})


  			
  			
  			
  			console.log(stocks)
  			// SCALE DOMAINS DEFINITION

  			// x0 positions the bars for the grouped bar based on the year
  			x0.domain(stocks.map(function(d) {return d.year}));
  			// x1 positions the bars for the grouped bar based on the symbol, taking in count the x0 bandwidth
  			x1.domain(keys)
  			.range([0,x0.bandwidth()-10]);
  			// y positions the bars for the grouped bar based on the price of the stocks (makes them higher)
  			// we take the max 
  			y.domain([0,d3.max(stocks, function(d) {
  													return d3.max(keys,function(symbol){
  																						return d[symbol]
  																						})
  													})
  			]);

  			// xStacks est similaire Ã  x
  			xStack.domain(stocks.map(function(d) {return d.year}));


  			




  			// Parses date and numbers, compute maximum and sum for later
  			ByDate.forEach(function(s) {
  				// Parses dates and numbers
			    s.values.forEach(function(d) { d.date = formatTime(parseDate(d.date)); d.price = +d.price; });
		   		s.maxPrice = d3.max(s.values, function(d) { return d.price; });
			    /*s.sumPrice = d3.sum(s.values, function(d) { return d.price; });*/
			  });

  			var g = svg.selectAll("g")
  			.data(ByDate)
  			.enter()
  			.append("g");


			var color = d3.scaleOrdinal()
				.domain(["MSFT","AMZN","IBM", "AAPL"])
				.range(["#81b900", "#ff9900", "#1f70c1", "#a7a9ac"]);

  			function groupedBar() {

  				// Define scales
  				// Scale for the position based on the date
				var x0 = d3.scaleBand()
				.domain(ByDate.map(function(d){return d.key}))
				.range([0,width]);

				// Scale for the position based on the date
				var x1 = d3.scaleBand()
			    .domain(ByDate[0].values.map(function(d) {return d.symbol}))
			    .range([0,x0.bandwidth()-1]);
			    // Scale for the y position of the bar
				var y = d3.scaleLinear()
				.domain([0,d3.max(ByDate.map(function(d) {return d.maxPrice}))])
			    .range([height/1.5,0]);

  				g.each(function(p) {

  					d3.select(this)
  					.selectAll("rect")
  					.data(function(d) { return d.values;})
  					.enter()
  					.append("rect")
  					.attr("x", function(d) {return x1(d.symbol)+x0(p.key);})
  					.attr("y",function(d) {return height/1.5-y(d.price);})
  					.attr("width",x1.bandwidth())
  					.attr("height",function(d) {return y(d.price);})
  					.style("fill",function(d) {return color(d.symbol);});

  				})}



  			function stackedBar() {
  				var keys = ByDate.map(function(d) {return d.key});

				var x = d3.scaleBand()
				.domain(ByDate.map(function(d){return d.key}))
				.range([0,width]);


				console.log(keys)
				console.log(d3.stack().keys(keys)([ByDate]))


  				g.each(function(p) {
  				d3.select(this)
  				.style("fill",function (d) {return color(d.symbol)})
  				.selectAll("rect")
  				.data(d3.stack().keys(keys)(function(d){return d.values}))
  				.enter()
  				.append("rect")
  				.attr("x", function(d) { return x(p.key); })
			    .attr("y", function(d) { return y(d[1]); })
			    .attr("height", function(d) { return y(d[0]) - y(d[1]); })
			    .attr("width", x.bandwidth());

			})


  			}
  			groupedBar();
  			stackedBar();


            });

        </script>
    </body>
</html>